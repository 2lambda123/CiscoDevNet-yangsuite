Project structure and design guidelines
=======================================

Directory and repository structure
----------------------------------

YANG Suite itself and its individual application plugins all follow a similar
directory structure::

    yangsuite.git
    ├── bin/
    |   └── setup_yangsuite.sh
    ├── docs/
    |   ├── developer/
    |   |   ├── design_guidelines.rst
    |   |   └── develop.rst
    |   └── user/
    |       └── index.rst
    ├── Makefile
    ├── README.rst
    ├── setup.py        definition for yangsuite package
    └── yangsuite/
        ├── apps.py
        ├── context_processors.py
        ├── static/
        │   └── yangsuite/
        │       ├── js/
        │       └── css/
        ├── templates/
        │   └── yangsuite/
        ├── tests/
        │   ├── test_context_processors.py
        │   └── test_doctests.py
        ├── urls.py        core YANG Suite URLs plus loading of app URLs
        └── views.py       core YANG Suite Django view functions

    yangsuite-devices.git
    ├── docs/
    |   ├── developer/
    |   |   ├── ysdevices.rst
    |   └── user/
    |       └── index.rst
    ├── Makefile
    ├── README.rst
    ├── setup.py           definition for yangsuite-devices package
    └── ysdevices/
        ├── apps.py        registration as a discoverable YANG Suite app
        ├── devprofile.py  application infrastructure (Django-agnostic)
        ├── static/
        │   └── ysdevices/
        │       ├── js/
        │       └── css/
        ├── templates/
        │   └── ysdevices/
        ├── tests/
        ├── urls.py        URLs provided to Django by ysdevices
        └── views.py       Django view functions provided by ysdevices

    yangsuite-netconf.git
    ├── docs/
    |   ├── developer/
    |   |   ├── ysnetconf.rst
    |   └── user/
    |       └── index.rst
    ├── Makefile
    ├── README.rst
    ├── setup.py           definition for yangsuite-netconf package
    └── ysnetconf/
        ├── apps.py        registration as a discoverable YANG Suite app
        ├── nconf.py       application infrastructure (Django-agnostic)
        ├── static/
        │   └── ysnetconf/
        │       ├── js/
        │       └── css/
        ├── templates/
        │   └── ysnetconf/
        ├── tests/
        ├── urls.py        URLs provided to Django by ysnetconf
        └── views.py       Django view functions provided by ysnetconf

    ...

Division of responsibilities between YANG Suite and apps
--------------------------------------------------------

- The core ``yangsuite`` project should be as lean as possible --
  it provides a basic infrastructure for installing all of the various apps,
  but provides very little YANG Suite application functionality itself.
- As such, adding new ``.py`` files to ``yangsuite`` will be considered
  suspect, as application functionality should be included in an application
  plugin instead.
- Each application should typically "do one thing and do it well" - don't be
  afraid to create a new application plugin if a new set of functionality is
  needed and it doesn't *very clearly* belong in an existing application.
- For any given application plugin, the Python package name (as defined in
  ``setup.py``, etc.) should generally be ``yangsuite-applicationname`` and
  app code should be in the ``ysapplicationname`` namespace,
  i.e. installed to ``site-packages/`` in a ``ysapplicationname/`` directory.

Application design and division of responsibilities
---------------------------------------------------

Applications should not be tightly coupled with Django or with a web interface
in general. There are cases where an application may wish to be executable from
the command line (interactively or non-) and we want to make that as
straightforward as possible to implement. Some practical implications:

- ``views.py`` should serve as little more than a translation layer between the
  web front-end (HTTP/HTML/JSON) and the underlying Python code (methods,
  objects, functions).
- Most of the actual 'work' of the application should be done in code that is
  unaware of Django or of the web front-end where applicable, such as:

  - API inputs should be Python objects (or possibly JSON strings), never
    ``HttpRequest`` (translation to be handled in the views functions).
  - API outputs should be Python objects (typically ``dict`` or plain-text
    ``str``), not ``JsonResponse`` or HTML ``str``.
  - Code in this module(s) shouldn't ever ``import django`` or similar.

- Using Django's "forms" APIs results in adding a lot of Django-specific
  input validation logic. It's usually better to implement this logic in the
  pure-Python code instead.
