Release process
===============
Process for releasing a new official version of ``yangsuite``.
A similar model generally applies to individual application plugins.

Branching model
---------------
YANG Suite follows a branching model similar to `Vincent Driessen's model`_.
In brief, the ``master`` branch should only be committed to as part of the
release of a new official version (see below). Commits by maintainers not
requiring significant review are committed to ``develop``, and feature
development work is done in a dedicated feature branch and then proposed as a
pull request against ``develop``.

Prerequisites
-------------

.. warning::

   You **MUST** check all of these things before creating the release!

Is ``develop`` passing all unit tests?
''''''''''''''''''''''''''''''''''''''

We **MUST NOT** release a version that does not pass testing. If the latest
commit on the ``develop`` branch either 1) fails a locally invoked ``tox`` run
or 2) is showing failures in Jenkins, then you **MUST** triage and fix the
failure(s) before the branch can be considered ready for release.

Is your new code dependent on new code in other plugins?
''''''''''''''''''''''''''''''''''''''''''''''''''''''''

1. Make sure the other plugin has a published release containing the new code.
   (Your release **MUST NOT** depend on a bleeding-edge / unreleased version
   of a different plugin)
2. You **MUST** ensure that your ``setup.py`` specifies the other plugin and
   its appropriate **release** version number as a minimum requirement.
   In other words, your ``setup.py`` must include a dependency like
   ``yangsuite-filemanager >= 1.2.0``, **NOT**
   ``yangsuite-filemanager >= 1.1.5.post0.dev12``. If necessary, make this
   fix in your ``develop`` branch before beginning the release process.

Are any other plugins dependent on this one?
''''''''''''''''''''''''''''''''''''''''''''

1. If at all possible, you **SHOULD** remain backwards-compatible with previous
   releases.
2. If this release will remove or significantly alter any API used by others,
   you **MUST**, following `Semantic Versioning`_ guidelines, make this a new
   **MAJOR** release (e.g., ``1.x.y`` --> ``2.0.0``) in order to avoid
   breakages.

Do you need to update any documentation or help pages?
''''''''''''''''''''''''''''''''''''''''''''''''''''''

You **MUST** verify that any help pages, README files, docstrings, and other
documentation accurately describe any new or altered features in this release.

Creating a new release
----------------------

Create a commit in the ``master`` branch
''''''''''''''''''''''''''''''''''''''''

As mentioned above, development work is done in the ``develop`` branch,
but releases should **always** happen from ``master``. Hence, a key step is
delivering the desired content to ``master``. Assuming the desired release
content is the latest version of ``develop``, we need to get this content into
the ``master`` branch::

    # Check with the upstream repository to see if there is new code in
    # any branch, and also if there are any new tags (see below)
    git fetch --tag
    # Make sure your local "develop" branch matches upstream latest
    git checkout develop
    git pull
    # Make sure your local "master" branch is up-to-date as well
    git checkout master
    git pull

    # Now merge the latest develop content into master as a new commit
    git merge --no-ff develop

Run unit tests
''''''''''''''

Run ``tox`` to execute the full set of unit tests as one last sanity check.
All tests **MUST** pass.

Select a new release version number
'''''''''''''''''''''''''''''''''''

Since you already made your repository aware of all existing upstream tags
as part of the ``git fetch --tag`` command above, you can now quickly check
which versions are already defined::

    git tag
    # example output:
    # v0.2.0
    # v0.2.1
    # v0.3.0

Based on the latest version number tagged so far, and the content of the new
release you are creating, select a new version number to update to, following
`Semantic Versioning`_ guidelines. For ease of reference throughout the
remainder of this document, we'll call this selected version NEW_VERSION,
e.g.::

    export NEW_VERSION=0.3.1

Create an annotated Git tag for this version
''''''''''''''''''''''''''''''''''''''''''''

Now it is time to add a Git tag identifying this latest commit in ``master``
as your selected new release version number::

    git tag -a "v$NEW_VERSION"

.. warning::

   Note the leading 'v'. For the ``versioneer`` library to correctly auto-number
   subsequent development versions (``$NEW_VERSION.post0.dev1``, etc.),
   the 'v' **must** be present.
   In other words, version 0.3.0 must be tag ``'v0.3.0'``, *not* ``'0.3.0'``!

This will open your text editor prompting for a tag annotation, very similar
to the commit comments you normally add.

**The text of this annotation will be included in the release announcement.**
You should treat this annotation as the user-facing release note for this
release. Highlight key bug fixes and features in this release. A generally
applicable template is something like::

    Version 0.3.1
    =============

    Features:

    - feature foobar (#27) is now supported
    - ...

    Fixes:

    - no longer incorrectly groks the xyzzy (#21)
    - ...

After committing the tag annotation, confirm that the version numbering,
as detected by ``versioneer`` and reported by Python, is updated correctly::

    > python setup.py --version
    0.3.1

If you see the old version number still, or a non-release version number (e.g.
``0.3.1.post0.dev``), then you have either named the tag incorrectly (did you
remember the leading 'v'?) or tagged the wrong commit.

If you make a mistake
~~~~~~~~~~~~~~~~~~~~~

If you inadvertently created the wrong tag, or tagged the wrong branch or
commit, it's easy to remove the tag, *so long as you haven't yet pushed the
tag upstream*::

    git tag --delete mybadtag

If you *have* already pushed the tag upstream, it is possible but **risky**
to delete it from upstream as well as locally.
See the "Discussion" section of ``git help tag`` for details and reasons why.

Publish the new release
'''''''''''''''''''''''

Push the commit and tag upstream::

    git push --follow-tags

.. note::

   You may wish to wait for Jenkins to run, validate the new release,
   and send out the automated release announcement before proceeding
   to the following steps.

Update the ``develop`` branch post-release
''''''''''''''''''''''''''''''''''''''''''

Now that you've created a new release, you must also update the ``develop``
branch to inherit from this release instead of the previous one.
This is needed to ensure new development versions have the new
version number as their base::

    git checkout develop
    git merge --no-ff master

Check that the versioning of ``develop`` is now correct. It should now be
the release version plus ``.post0.dev1``, indicating the first development
commit post-release::

    > python setup.py --version
    0.3.1.post0.dev1

Push the updated ``develop`` branch upstream as well::

    git push

.. note::

   Jenkins will handle things from here as far as building and uploading the
   new release to our PyPI server. If for some reason Jenkins fails to do so,
   continue to the `Manually publishing a release`_ section below.

Manually publishing a release
-----------------------------

.. note::

   Normally the release will be automatically published by Jenkins after you
   follow the above steps. You should only need to follow this section if
   something goes wrong in Jenkins.

Build the package as a Python wheel
'''''''''''''''''''''''''''''''''''

Pre-clean your workspace to remove any prior builds or packages,
just to be safe::

    make clean

Make sure you are working out of the ``master`` branch and the version number
is as expected::

    git checkout master
    python setup.py --version

If all is well, now build the new package and package it into a wheel::

    make

The new wheel will be in the ``./dist/`` directory and should be named with
your package name and the new release tag, something along the lines of
``PACKAGE_NAME-RELEASE_VERSION-py2.py3-none-any.whl``.

Check your pypirc file
''''''''''''''''''''''

Make sure you have our internal repository, ``yang-suite-dev-pypi-local``,
set up in your ``~/.pypirc`` file, as we are not yet publishing our code to the
public PyPI server at https://pypi.python.org/pypi\ .

Reach out to yang-suite-dev@cisco.com if you need the password for publishing
to our repository.

Example pypirc content::

    [distutils]
    index-servers =
        pypi
        yang-suite-dev-pypi-local

    [pypi]
    ...

    [yang-suite-dev-pypi-local]
    repository: https://engci-maven-master.cisco.com/artifactory/api/pypi/yang-suite-dev-pypi-local
    username: yang-suite-deployer
    password: <PASSWORD GOES HERE>

Install ``twine``
'''''''''''''''''

We recomment using `twine`_ to publish the package as it streamlines some of the
rough edges of using the built-in ``python setup.py upload`` command.
Make sure you have the latest version installed in your virtualenv::

    pip install twine --upgrade

Publish the wheel to our PyPI repository
''''''''''''''''''''''''''''''''''''''''

Upload the wheel you just built to our release repository::

    twine upload --repository yang-suite-dev-pypi-local ./dist/*.whl

Notify users of the new release
'''''''''''''''''''''''''''''''

Send an email notification to ``yang-suite-users@cisco.com`` and
``yang-suite-support@cisco.com`` announcing the new release and its key
features and fixes. An example template, similar to what Jenkins uses,
would be as follows.

Subject: ``New release: {{ project }} version {{ version }}``

Body::

    A new version of {{ project }}, {{ version }}, has been released.
    Release notes are as follows:

    {{ tag_annotation }}

    To update an existing YANG Suite install, simply run the setup_yangsuite
    script again.  It will detect the new version and update your instance
    without losing any of your previous settings, repositories, or yangsets.
    Be sure and refresh your browser.

            Thanks,

                YANG Suite development team

.. _Semantic Versioning: http://semver.org/
.. _Vincent Driessen's model: http://nvie.com/posts/a-successful-git-branching-model/
.. _twine: https://pypi.python.org/pypi/twine
