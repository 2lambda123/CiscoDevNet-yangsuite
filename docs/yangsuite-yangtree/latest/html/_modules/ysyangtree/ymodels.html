

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ysyangtree.ymodels &mdash; yangsuite-yangtree 1.19.1.post0.dev3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> yangsuite-yangtree
          

          
          </a>

          
            
            
              <div class="version">
                1.19.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user/index.html">Working with YANG Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developer/index.html">ysyangtree developer documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">yangsuite-yangtree</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ysyangtree.ymodels</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ysyangtree.ymodels</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Transform YANG models into a dict.</span>

<span class="sd">YSYangModels: Holds multiple YANG models in dict format in a list.</span>
<span class="sd">              This class allows message builders to construct multiple</span>
<span class="sd">              protocol messages in a single communication.</span>

<span class="sd">ParseYang: Parses a single YANG model into a dict.  Extracts relevant</span>
<span class="sd">           data of each YANG statement while maintaining the hierarchy</span>
<span class="sd">           of the model within children dict.</span>

<span class="sd">TreeWalker: Contains various functions that can extract targeted data</span>
<span class="sd">            from the dict created by ParseYang.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pyang</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">yangsuite.logs</span> <span class="kn">import</span> <span class="n">get_logger</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">ALL_NODETYPES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
    <span class="s1">&#39;action&#39;</span><span class="p">,</span>
    <span class="s1">&#39;anydata&#39;</span><span class="p">,</span>
    <span class="s1">&#39;anyxml&#39;</span><span class="p">,</span>
    <span class="s1">&#39;case&#39;</span><span class="p">,</span>
    <span class="s1">&#39;choice&#39;</span><span class="p">,</span>
    <span class="s1">&#39;container&#39;</span><span class="p">,</span>
    <span class="s1">&#39;grouping&#39;</span><span class="p">,</span>
    <span class="s1">&#39;identity&#39;</span><span class="p">,</span>
    <span class="s1">&#39;input&#39;</span><span class="p">,</span>
    <span class="s1">&#39;leaf&#39;</span><span class="p">,</span>
    <span class="s1">&#39;leaf-list&#39;</span><span class="p">,</span>
    <span class="s1">&#39;list&#39;</span><span class="p">,</span>
    <span class="s1">&#39;module&#39;</span><span class="p">,</span>
    <span class="s1">&#39;notification&#39;</span><span class="p">,</span>
    <span class="s1">&#39;output&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rpc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;submodule&#39;</span><span class="p">,</span>
    <span class="s1">&#39;typedef&#39;</span><span class="p">,</span>
<span class="p">})</span>

<span class="n">NON_SCHEMA_NODETYPES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
    <span class="s1">&#39;grouping&#39;</span><span class="p">,</span>
    <span class="s1">&#39;identity&#39;</span><span class="p">,</span>
    <span class="s1">&#39;typedef&#39;</span><span class="p">,</span>
<span class="p">})</span>
<span class="sd">&quot;&quot;&quot;Node types that are in neither the schema tree nor the data tree.&quot;&quot;&quot;</span>

<span class="n">NON_DATA_NODETYPES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
    <span class="n">NON_SCHEMA_NODETYPES</span><span class="o">.</span><span class="n">union</span><span class="p">({</span>
        <span class="s1">&#39;case&#39;</span><span class="p">,</span>
        <span class="s1">&#39;choice&#39;</span><span class="p">,</span>
        <span class="s1">&#39;input&#39;</span><span class="p">,</span>
        <span class="s1">&#39;output&#39;</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Node types that are not in the data tree.&quot;&quot;&quot;</span>

<span class="n">DEFAULT_INCLUDED_NODETYPES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">ALL_NODETYPES</span> <span class="o">-</span> <span class="n">NON_SCHEMA_NODETYPES</span><span class="p">)</span>


<div class="viewcode-block" id="YSYangModels"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.YSYangModels">[docs]</a><span class="k">class</span> <span class="nc">YSYangModels</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Object representing one or more ParseYang instances.&quot;&quot;&quot;</span>

    <span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="YSYangModels.get_instance"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.YSYangModels.get_instance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the instance cached under the given key.</span>

<span class="sd">        Returns:</span>
<span class="sd">          YSYangModels: instance, or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="YSYangModels.store_instance"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.YSYangModels.store_instance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">store_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the given instance under the given key.</span>

<span class="sd">        Args:</span>
<span class="sd">          inst (YSYangModels): instance to store</span>
<span class="sd">          key (str): Key to store the instance under for future reference.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected </span><span class="si">{0}</span><span class="s2"> but got </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">inst</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Replacing cached instance </span><span class="si">%s</span><span class="s1"> with </span><span class="si">%s</span><span class="s1"> under key &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
                     <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">inst</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">inst</span></div>

<div class="viewcode-block" id="YSYangModels.forget_instance"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.YSYangModels.forget_instance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">forget_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the instance under the given key from the cache.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">modulenames</span><span class="p">,</span>
                 <span class="n">include_augmentees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">include_supermodules</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">child_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">included_nodetypes</span><span class="o">=</span><span class="n">DEFAULT_INCLUDED_NODETYPES</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct ParseYang instances for the given modules and user ctx.</span>

<span class="sd">        Args:</span>
<span class="sd">          ctx (YSContext): User context</span>
<span class="sd">          modulenames (list): One or more YANG modules to describe</span>
<span class="sd">          include_augmentees (bool): If True, automatically extend modulenames</span>
<span class="sd">            to include the module(s) augmented by these modules</span>
<span class="sd">          include_supermodules (bool): If True, if modulenames contains any</span>
<span class="sd">            submodules, automatically extend modulenames with the modules they</span>
<span class="sd">            belong to.</span>
<span class="sd">          child_class (class): Defaults to :class:`ParseYang`.</span>
<span class="sd">          included_nodetypes (set): Nodetype strings to include in</span>
<span class="sd">            the constructed instance trees.</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: if ``include_augmentees`` or ``include_supermodules`` is</span>
<span class="sd">            True but ``ctx.repository`` is not a :class:`YSYangSet` or similar</span>
<span class="sd">            class (e.g., a generic :class:`pyang.Repository` would trigger</span>
<span class="sd">            this error).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">child_class</span><span class="p">:</span>
            <span class="n">child_class</span> <span class="o">=</span> <span class="n">ParseYang</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yangs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span> <span class="o">=</span> <span class="n">included_nodetypes</span>
        <span class="n">all_modules</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">modulenames</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include_augmentees</span> <span class="ow">or</span> <span class="n">include_supermodules</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">repository</span><span class="p">,</span> <span class="s1">&#39;digraph&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ctx.repository (</span><span class="si">{0}</span><span class="s2">) doesn&#39;t have a digraph&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">repository</span><span class="p">))</span>
            <span class="n">dg</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">repository</span><span class="o">.</span><span class="n">digraph</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">new_modules</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_modules</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">include_augmentees</span><span class="p">:</span>
                        <span class="n">new_modules</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;augments&#39;</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">subname</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;includes&#39;</span><span class="p">]:</span>
                            <span class="n">new_modules</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dg</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">subname</span><span class="p">][</span><span class="s1">&#39;augments&#39;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">include_supermodules</span> <span class="ow">and</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;kind&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;submodule&#39;</span><span class="p">:</span>
                        <span class="n">new_modules</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;belongs-to&#39;</span><span class="p">])</span>

                <span class="n">new_modules</span> <span class="o">-=</span> <span class="n">all_modules</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_modules</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Added </span><span class="si">%d</span><span class="s2"> extra modules </span><span class="si">%s</span><span class="s2"> to base modules </span><span class="si">%s</span><span class="s2"> &quot;</span>
                          <span class="s2">&quot;as augmentation targets and/or supermodules&quot;</span><span class="p">,</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">new_modules</span><span class="p">),</span> <span class="n">new_modules</span><span class="p">,</span> <span class="n">modulenames</span><span class="p">)</span>
                <span class="n">all_modules</span> <span class="o">|=</span> <span class="n">new_modules</span>

        <span class="c1"># Make sure the ctx has loaded all of these modules</span>
        <span class="n">loaded_modules</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">rev</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">mod</span> <span class="ow">in</span> <span class="n">loaded_modules</span> <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="n">all_modules</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">load_module_files</span><span class="p">(</span><span class="n">all_modules</span> <span class="o">-</span> <span class="n">loaded_modules</span><span class="p">)</span>

        <span class="c1"># Add requested modules first, followed by extras in sorted order</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">modulenames</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_modules</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">modulenames</span><span class="p">)):</span>
            <span class="c1"># Fail gracefully if modules are somehow unavailable</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yangs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">child_class</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodeid</span><span class="p">,</span>
                    <span class="n">included_nodetypes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Unable to locate module &quot;</span><span class="si">%s</span><span class="s1">&quot; in context &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
                            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yangs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return class name, YANG models parsed, and context instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> (YANG models </span><span class="si">{1}</span><span class="s2">, context </span><span class="si">{2}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yangs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">modelnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return sorted YANG model names parsed in class.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yangs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">jstree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dict with key &#39;data&#39;: list of trees for each contained ParseYang.&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">psy</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">yangs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">psy</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psy</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Failed loading</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;text&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                    <span class="s1">&#39;icon&#39;</span><span class="p">:</span> <span class="s2">&quot;fas fa-lg fa-exclamation-triangle&quot;</span><span class="p">,</span>
                    <span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="s2">&quot;Module not found or loading failed&quot;</span><span class="p">,</span>
                    <span class="p">},</span>
                    <span class="s1">&#39;a_attr&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="s1">&#39;result-error&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="s1">&#39;color:darkred&#39;</span><span class="p">}})</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span>
                <span class="s1">&#39;included_nodetypes&#39;</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">)}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">included_nodetypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span>

    <span class="nd">@included_nodetypes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">included_nodetypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">yangs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">child</span><span class="o">.</span><span class="n">included_nodetypes</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="ParseYang"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang">[docs]</a><span class="k">class</span> <span class="nc">ParseYang</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper module to YSContext and pyang.</span>

<span class="sd">    The instance attribute :attr:`ParseYang.tree` provides a structured</span>
<span class="sd">    representation of a single module and its dependencies.</span>

<span class="sd">    .. seealso:: :attr:`tree`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MODULE_OPERATIONS</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
        <span class="s1">&#39;edit-config&#39;</span><span class="p">,</span>
        <span class="s1">&#39;get&#39;</span><span class="p">,</span>
        <span class="s1">&#39;get-config&#39;</span><span class="p">,</span>
        <span class="s1">&#39;notification&#39;</span><span class="p">,</span>
        <span class="s1">&#39;rpc&#39;</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="sd">&quot;&quot;&quot;Operation values that may be seen on a root &#39;module&#39; node.&quot;&quot;&quot;</span>

    <span class="n">NODE_OPERATIONS</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
        <span class="s1">&#39;edit-config&#39;</span><span class="p">,</span>
        <span class="s1">&#39;get&#39;</span><span class="p">,</span>
        <span class="s1">&#39;get-config&#39;</span><span class="p">,</span>
        <span class="s1">&#39;input&#39;</span><span class="p">,</span>          <span class="c1"># RPC &#39;input&#39; statement</span>
        <span class="s1">&#39;notification&#39;</span><span class="p">,</span>
        <span class="s1">&#39;output&#39;</span><span class="p">,</span>         <span class="c1"># RPC &#39;output&#39; statement</span>
        <span class="s1">&#39;rpc&#39;</span><span class="p">,</span>
    <span class="p">})</span>
    <span class="sd">&quot;&quot;&quot;Operation values that may be seen on any non-module node in the tree.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span>
                 <span class="n">nodeid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">included_nodetypes</span><span class="o">=</span><span class="n">DEFAULT_INCLUDED_NODETYPES</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a ParseYang for the given schema name and user ctx.</span>

<span class="sd">        Args:</span>
<span class="sd">          name (str): YANG schema name.</span>
<span class="sd">          revision (str): Revision string. Leave blank to get the latest</span>
<span class="sd">            revision available.</span>
<span class="sd">          ctx (YSContext): User context.</span>
<span class="sd">          nodeid (itertools.count): Existing iterator to use to assign node IDs</span>
<span class="sd">            within this instance&#39;s node tree. If not provided, a new iterator</span>
<span class="sd">            will be constructed to use node IDs beginning at 1.</span>
<span class="sd">          included_nodetypes (tuple): List of nodetype strings to include</span>
<span class="sd">            in the generated tree.</span>

<span class="sd">        Raises:</span>
<span class="sd">          ValueError: if the requested module is not available</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">revision</span> <span class="o">=</span> <span class="n">revision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span> <span class="o">=</span> <span class="n">included_nodetypes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The root :class:`pyang.statements.Statement` for module &#39;name&#39;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ctx</span><span class="o">.</span><span class="n">invalid_modules</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module &#39;</span><span class="si">%s</span><span class="s2"> @ </span><span class="si">%s</span><span class="s2">&#39; failed loading in ctx &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                          <span class="n">name</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
                <span class="c1"># TODO: grab ctx.errors[name][rev] and report it?</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Module &#39;</span><span class="si">{0}</span><span class="s2"> @ </span><span class="si">{1}</span><span class="s2">&#39; was not loaded successfully &quot;</span>
                    <span class="s2">&quot;by pyang or YSContext and so cannot be rendered.&quot;</span>
                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Neither valid nor invalid - missing altogether</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module &#39;</span><span class="si">%s</span><span class="s2"> @ </span><span class="si">%s</span><span class="s2">&#39; not found in ctx </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="n">name</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;ctx.modules: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;ctx.revs: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">revs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to locate module &#39;</span><span class="si">{0}</span><span class="s2"> @ </span><span class="si">{1}</span><span class="s2">&#39; in </span><span class="si">{2}</span><span class="s2">; &quot;</span>
                                 <span class="s2">&quot;has it been loaded?&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">revision</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="c1"># Initialize and set default values for various attributes:</span>
        <span class="k">if</span> <span class="n">nodeid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">nodeid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">missing_typedefs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;Missing typedefs that have already been reported to the user.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;Dictionary representing the parsed module as a tree.</span>

<span class="sd">        This tree has a structured format analogous to the JSON data used by</span>
<span class="sd">        `jsTree`_, where each tree node is a dictionary with any or all</span>
<span class="sd">        of the following items:</span>

<span class="sd">        id : str</span>
<span class="sd">          Unique identifier of this node. In the current implementation,</span>
<span class="sd">          a monotonically increasing counter (:func:`itertools.count`), but</span>
<span class="sd">          users should not depend on this particular implementation.</span>
<span class="sd">        text : str</span>
<span class="sd">          Text label for this node</span>
<span class="sd">        icon : str</span>
<span class="sd">          `Font Awesome`_ class to represent this node.</span>
<span class="sd">          (May also be a path to an image file per `jsTree`_, but we don&#39;t use</span>
<span class="sd">          that option at present).</span>
<span class="sd">        a_attr : dict</span>
<span class="sd">          HTML attributes to add to the ``&lt;a&gt;...&lt;/a&gt;`` element that `jsTree`_</span>
<span class="sd">          will generate from this node.</span>
<span class="sd">        data : dict</span>
<span class="sd">          YANG data associated with this node - specific to this application,</span>
<span class="sd">          and generally opaque to `jsTree`_ itself.</span>
<span class="sd">        children : list</span>
<span class="sd">          Direct children of this node, each represented as its own node</span>
<span class="sd">          dictionary like this one (with potential children of its own, etc.)</span>

<span class="sd">        Additional keys that `jsTree`_ recognizes but are not currently</span>
<span class="sd">        populated by this class include :attr:`state` and :attr:`li_attr`.</span>

<span class="sd">        .. _`Font Awesome`: https://fontawesome.com</span>
<span class="sd">        .. _jsTree: https://www.jstree.com/docs/json/</span>

<span class="sd">        .. seealso::</span>

<span class="sd">           :meth:`get_module_node_data`</span>
<span class="sd">             Contents of the ``data`` dict for the root-level node representing</span>
<span class="sd">             the module or submodule associated with this instance.</span>

<span class="sd">           :meth:`get_node_data`</span>
<span class="sd">             Contents of the ``data`` dict for all other tree nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Now populate the real values:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_tree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tw</span> <span class="o">=</span> <span class="n">TreeWalker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">included_nodetypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of nodetype strings included in :attr:`self.tree`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span>

    <span class="nd">@included_nodetypes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">included_nodetypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_included_nodetypes</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># Regenerate the tree with the new set of nodetypes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_tree</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tw</span> <span class="o">=</span> <span class="n">TreeWalker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of operations allowed for this module&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;operations&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="ParseYang.generate_tree"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.generate_tree">[docs]</a>    <span class="k">def</span> <span class="nf">generate_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(Re)generate a dictionary that can be used as :attr:`self.tree`.</span>

<span class="sd">        Args:</span>
<span class="sd">          node_callback (function): Function to call for each node in the tree</span>
<span class="sd">            in order to populate additional data into the tree. Must accept</span>
<span class="sd">            kwargs ``stmt``, ``node``, and ``parent_data``</span>
<span class="sd">            (which may be ``None``), and return ``node``.</span>

<span class="sd">        Returns:</span>
<span class="sd">          dict: See :attr:`self.tree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_module_node_data</span><span class="p">(</span><span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">)</span>

        <span class="n">modulechildren</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="s1">&#39;identity&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">i_identities</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">modulechildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                    <span class="n">child</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">&#39;typedef&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">i_typedefs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">modulechildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                    <span class="n">child</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">&#39;grouping&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">i_groupings</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">modulechildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                    <span class="n">child</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">i_children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">:</span>
                <span class="n">modulechildren</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                    <span class="n">child</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">modulechildren</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tree</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">modulechildren</span>

        <span class="k">return</span> <span class="n">tree</span></div>

<div class="viewcode-block" id="ParseYang.get_module_node_data"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_module_node_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_module_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the node dictionary for the module itself.</span>

<span class="sd">        Args:</span>
<span class="sd">          node_callback (function): Callback function, should take ``stmt``,</span>
<span class="sd">            ``node``, and ``parent_data`` (possibly ``None``) as kwargs and</span>
<span class="sd">            return the updated ``node`` dictionary.</span>

<span class="sd">        The base dictionary for all nodes are as described under :attr:`tree`;</span>
<span class="sd">        for this base node, the :attr:`data` sub-dictionary (actually an</span>
<span class="sd">        :class:`~collections.OrderedDict`) will have the following items, in</span>
<span class="sd">        the following order:</span>

<span class="sd">        module : str</span>
<span class="sd">          Name of this module, or, if this is a submodule, the name of the</span>
<span class="sd">          module it ``belongs-to``.</span>
<span class="sd">        submodule : str</span>
<span class="sd">          Name of this submodule, if it is a submodule.</span>
<span class="sd">        revision : str</span>
<span class="sd">          Latest revision date of this (sub)module.</span>
<span class="sd">        revision_info : str</span>
<span class="sd">          Any description string associated with the latest revision.</span>
<span class="sd">        description : str</span>
<span class="sd">          The description string for the (sub)module as a whole.</span>
<span class="sd">        organization : str</span>
<span class="sd">          The organization string for this (sub)module.</span>
<span class="sd">        imports : list</span>
<span class="sd">          List of &quot;module-name&quot; or &quot;module-name revision&quot; strings</span>
<span class="sd">          identifying the modules imported by this module.</span>
<span class="sd">        namespace : str</span>
<span class="sd">          Namespace string used by this module, such as</span>
<span class="sd">          &quot;urn:ietf:params:xml:ns:yang:ietf-routing&quot;.</span>
<span class="sd">        prefix : str</span>
<span class="sd">          Namespace prefix string used by this module, such as &quot;rt&quot;.</span>
<span class="sd">        namespace_prefixes : dict</span>
<span class="sd">          Sub-dictionary mapping namespace prefixes</span>
<span class="sd">          to the corresponding namespace strings for all namespaces known to</span>
<span class="sd">          this module. Example::</span>

<span class="sd">            {</span>
<span class="sd">              &#39;rt&#39;:   &quot;urn:ietf:params:xml:ns:yang:ietf-routing&quot;,</span>
<span class="sd">              &#39;yang&#39;: &quot;urn:ietf:params:xml:ns:yang:ietf-yang-types&quot;,</span>
<span class="sd">              &#39;if&#39;:   &quot;urn:ietf:params:xml:ns:yang:ietf-interfaces&quot;,</span>
<span class="sd">            }</span>

<span class="sd">        modtype : str</span>
<span class="sd">          Either &quot;module&quot; or &quot;submodule&quot;</span>
<span class="sd">        operations : list</span>
<span class="sd">          Strings representing the NETCONF operations supported by this module;</span>
<span class="sd">          see :const:`MODULE_OPERATIONS` for the possible values.</span>

<span class="sd">        Returns:</span>
<span class="sd">          dict: &#39;node&#39; dictionary containing parsed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">module</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodeid</span><span class="p">),</span> <span class="s1">&#39;text&#39;</span><span class="p">:</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">}</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># Keys will typically be displayed in the insertion order by the UI, so</span>
        <span class="c1"># some thought has been put into this ordering:</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s2">&quot;module&quot;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;module&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span>
            <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fas fa-lg fa-cubes ystree-root&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;submodule&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;module&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_modulename</span>
            <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fas fa-cube ystree-root&#39;</span>

        <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">([</span>
            <span class="c1"># Immediately relevant to casual viewers</span>
            <span class="p">(</span><span class="s1">&#39;revision&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;revision_info&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subst_arg</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;organization&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
            <span class="c1"># Of interest to intermediate users</span>
            <span class="p">(</span><span class="s1">&#39;imports&#39;</span><span class="p">,</span> <span class="p">[]),</span>
            <span class="p">(</span><span class="s1">&#39;namespace&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;prefix&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;namespace_prefixes&#39;</span><span class="p">,</span> <span class="p">{}),</span>
            <span class="c1"># Advanced / developer / API information</span>
            <span class="p">(</span><span class="s1">&#39;modtype&#39;</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;operations&#39;</span><span class="p">,</span> <span class="p">[]),</span>
        <span class="p">])</span>

        <span class="c1"># Per RFC module MUST always have a namespace statement.</span>
        <span class="c1"># However, let&#39;s not error out unless we need to.</span>
        <span class="c1"># If no namespace, default data[&#39;namespace&#39;] to self.namespace</span>
        <span class="c1"># (which in turn defaults to &#39;&#39;), rather than None.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;namespace&#39;</span><span class="p">,</span>
                                                 <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span>

        <span class="c1"># Likewise, mandatory prefix statement - defaulting to &#39;&#39; if missing.</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_prefix</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_prefix</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;prefix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span>

        <span class="n">nspdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;namespace_prefixes&#39;</span><span class="p">]</span>

        <span class="c1"># We may need namespace from identityref so make it available</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspdata</span> <span class="o">=</span> <span class="n">nspdata</span>

        <span class="n">all_i_prefixes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_prefixes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="n">pfx</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Add prefix-to-module mapping unless prefix is already used.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">pfx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_i_prefixes</span><span class="p">:</span>
                <span class="n">all_i_prefixes</span><span class="p">[</span><span class="n">pfx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">all_i_prefixes</span><span class="p">[</span><span class="n">pfx</span><span class="p">]:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Prefix </span><span class="si">%s</span><span class="s2"> is used for both </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">!&quot;</span><span class="p">,</span>
                                <span class="n">pfx</span><span class="p">,</span> <span class="n">all_i_prefixes</span><span class="p">[</span><span class="n">pfx</span><span class="p">],</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">add_prefixes</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">base_pfx</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Add prefix-to-module mappings from the stmt&#39;s prefixes.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pfx</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_prefixes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">pfx</span> <span class="o">!=</span> <span class="n">base_pfx</span><span class="p">:</span>
                        <span class="n">add_prefix</span><span class="p">(</span><span class="n">pfx</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>

        <span class="c1"># Handle everything in stmt.i_prefixes, plus everything in</span>
        <span class="c1"># each augmenter&#39;s, deriver&#39;s, and submodule&#39;s i_prefixes</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">pfx</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">))</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_prefixes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">pfx</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;imports&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mod</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot; @ &quot;</span> <span class="o">+</span> <span class="n">rev</span><span class="p">)</span> <span class="k">if</span> <span class="n">rev</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">aug_mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">augmenters_of</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">add_prefixes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="n">aug_mod</span><span class="p">),</span> <span class="n">pfx</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">id_mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">identity_derivers_of</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">add_prefixes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="n">id_mod</span><span class="p">),</span> <span class="n">pfx</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">submod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">submodules_of</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">add_prefixes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="n">submod</span><span class="p">),</span> <span class="n">pfx</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">pfx</span><span class="p">,</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_i_prefixes</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">mod_stmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mod_stmt</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No module </span><span class="si">%s</span><span class="s2">, can&#39;t get namespace for prefix </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">mod</span><span class="p">,</span> <span class="n">pfx</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Set nspdata[pfx] = namespace, if found</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">nspdata</span><span class="p">,</span> <span class="n">mod_stmt</span><span class="p">,</span> <span class="s1">&#39;namespace&#39;</span><span class="p">,</span>
                                    <span class="n">data_key</span><span class="o">=</span><span class="n">pfx</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;organization&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">revision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;revision&#39;</span><span class="p">,</span>
                                                <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">revision</span><span class="p">)</span>
        <span class="n">rev</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;revision&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rev</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">,</span>
                                <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;revision_info&#39;</span><span class="p">)</span>

        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">if</span> <span class="n">node_callback</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node_callback</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="n">stmt</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span></div>

    <span class="n">STMT_ICONS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;action&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-bullseye ystree-root&#39;</span><span class="p">,</span>
        <span class="s2">&quot;anydata&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-asterisk ystree-leaf&#39;</span><span class="p">,</span>
        <span class="s2">&quot;anyxml&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-code ystree-leaf&#39;</span><span class="p">,</span>
        <span class="s2">&quot;case&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-arrow-right ystree-node&#39;</span><span class="p">,</span>
        <span class="s2">&quot;choice&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-code-branch ystree-node&#39;</span><span class="p">,</span>
        <span class="s2">&quot;container&quot;</span><span class="p">:</span> <span class="s1">&#39;far fa-lg fa-folder-open ystree-node&#39;</span><span class="p">,</span>
        <span class="s2">&quot;grouping&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-cube ystree-definition&#39;</span><span class="p">,</span>
        <span class="s2">&quot;identity&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-info ystree-definition&#39;</span><span class="p">,</span>
        <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-sign-in-alt ystree-node&#39;</span><span class="p">,</span>
        <span class="s2">&quot;leaf&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-leaf ystree-leaf&#39;</span><span class="p">,</span>
        <span class="s2">&quot;leaf-list&quot;</span><span class="p">:</span> <span class="s1">&#39;fab fa-lg fa-pagelines ystree-leaf&#39;</span><span class="p">,</span>
        <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-list ystree-node&#39;</span><span class="p">,</span>
        <span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-cubes ystree-root&#39;</span><span class="p">,</span>
        <span class="s2">&quot;notification&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-gift ystree-root&#39;</span><span class="p">,</span>
        <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-lg fa-sign-out-alt ystree-node&#39;</span><span class="p">,</span>
        <span class="s2">&quot;rpc&quot;</span><span class="p">:</span> <span class="s1">&#39;far fa-lg fa-envelope ystree-root&#39;</span><span class="p">,</span>
        <span class="s2">&quot;submodule&quot;</span><span class="p">:</span> <span class="s1">&#39;fas fa-cube ystree-root&#39;</span><span class="p">,</span>
        <span class="s2">&quot;typedef&quot;</span><span class="p">:</span> <span class="s1">&#39;far fa-lg fa-star ystree-definition&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="sd">&quot;&quot;&quot;Simple suggested Font Awesome node icons.</span>

<span class="sd">    These may (in fact, should) be overridden by more complex icons</span>
<span class="sd">    (with layering, badges, etc.) on the client side, but we can at least</span>
<span class="sd">    provide some not-too-ugly defaults in case the client declines to do so.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ParseYang.get_node_data"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_node_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span>
                      <span class="n">parent_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the node dictionary for a given Statement and its children.</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): Child statement to process.</span>
<span class="sd">          parent_data (dict): Data previously constructed by this method</span>
<span class="sd">            for the stmt&#39;s parent statement.</span>
<span class="sd">          node_callback (function): Callback function, should take ``stmt``,</span>
<span class="sd">            ``node``, and ``parent_data`` as kwargs and return the updated</span>
<span class="sd">            ``node`` dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">          dict: Node data, as described below.</span>

<span class="sd">        The base data for any node are as described under :attr:`tree`;</span>
<span class="sd">        for any statement node passed through this method, the :attr:`data`</span>
<span class="sd">        sub-dictionary (actually an :class:`~collections.OrderedDict`)</span>
<span class="sd">        will receive some or all of the following items in the following order:</span>

<span class="sd">        name : str</span>
<span class="sd">          The name (YANG identifier) of this node, such as &quot;routing-state&quot;</span>
<span class="sd">        nodetype : str</span>
<span class="sd">          The type (YANG keyword) of this node, such as &quot;container&quot;, &quot;list&quot;,</span>
<span class="sd">          &quot;leaf&quot;, etc.</span>
<span class="sd">        deviation : str</span>
<span class="sd">          The string &quot;not-supported&quot;, iff this node has been marked as</span>
<span class="sd">          not-supported by a deviation file.</span>
<span class="sd">        status : str</span>
<span class="sd">          The string &quot;deprecated&quot; or &quot;obsolete&quot; iff this node&#39;s status is</span>
<span class="sd">          marked as such. Note that this key is omitted to save room when</span>
<span class="sd">          the node&#39;s status is &quot;current&quot; (either explicitly or implicitly).</span>
<span class="sd">        datatype : str</span>
<span class="sd">          For ``leaf`` and ``leaf-list`` nodes, the associated data ``type``</span>
<span class="sd">          for this node. Otherwise absent.</span>
<span class="sd">        description : str</span>
<span class="sd">          The ``description`` string associated with this statement.</span>
<span class="sd">        module : str</span>
<span class="sd">          The module this statement belongs to</span>
<span class="sd">        revision : str</span>
<span class="sd">          The latest revision data of the owning module</span>
<span class="sd">        xpath : str</span>
<span class="sd">          `Data node`_ XPath to reach this node via the data tree,</span>
<span class="sd">          starting from the module root. Node names local to this module will</span>
<span class="sd">          not be prefixed, while those from other modules will be prefixed.</span>
<span class="sd">          Example:</span>
<span class="sd">          ``/interfaces/interface/subinterfaces/subinterface/vlan:vlan``</span>
<span class="sd">        prefix : str</span>
<span class="sd">          Module namespace prefix applicable to this node.</span>
<span class="sd">        namespace : str</span>
<span class="sd">          Module namespace of this node.</span>
<span class="sd">        mandatory : str</span>
<span class="sd">          The string &quot;true&quot;, iff this node is mandatory</span>
<span class="sd">          (a ``leaf`` or ``choice`` with a ``mandatory`` substatement,</span>
<span class="sd">          or a ``list`` or ``leaf-list`` with non-zero ``min-elements``,</span>
<span class="sd">          or a ``container`` that has any of the above as children).</span>
<span class="sd">          Omitted (*not* &quot;false&quot;) if non-mandatory.</span>
<span class="sd">        must : str</span>
<span class="sd">          Text of any ``must`` XPath expression associated with this node.</span>
<span class="sd">        when : str</span>
<span class="sd">          Text of any ``when`` XPath expression associated with this node.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          :meth:`get_stmt_specific_data`</span>
<span class="sd">            May populate additional item(s) into :attr:`data` at this point,</span>
<span class="sd">            depending on the particular statement keyword.</span>
<span class="sd">          :meth:`get_type_specific_data`</span>
<span class="sd">            Called from :meth:`get_stmt_specific_data` for ``leaf`` and</span>
<span class="sd">            ``leaf-list`` statements, may populate additional :attr:`data` here</span>
<span class="sd">            according to the statement&#39;s :attr:`datatype`.</span>

<span class="sd">        Finally the following items may be added as well by this method:</span>

<span class="sd">        access : str</span>
<span class="sd">          One of &quot;read-only&quot;, &quot;read-write&quot;, or &quot;write&quot;</span>
<span class="sd">        operations : list</span>
<span class="sd">          Operations that can be performed on this node.</span>
<span class="sd">          See :const:`NODE_OPERATIONS` for possible operations. Note that a</span>
<span class="sd">          node such as a ``choice`` or ``case`` may be &quot;read-write&quot; and yet</span>
<span class="sd">          have no applicable operations, as the operations apply</span>
<span class="sd">          specifically to its child nodes.</span>
<span class="sd">        xpath_pfx : str</span>
<span class="sd">          `Data node`_ identifier, as :attr:`xpath`, but</span>
<span class="sd">          prefixing all names, even those local to this module.</span>
<span class="sd">        schema_node_id : str</span>
<span class="sd">          `Schema node identifier`_, path to this node via the schema tree.</span>
<span class="sd">          May be identical to :attr:`xpath` but may also include non-data</span>
<span class="sd">          nodes not in :attr:`xpath`, as described in RFC 6020.</span>

<span class="sd">        .. _`Data node`: https://tools.ietf.org/html/rfc6020#section-3</span>
<span class="sd">        .. _`Schema node identifier`:</span>
<span class="sd">          https://tools.ietf.org/html/rfc6020#section-6.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Don&#39;t prefix locally defined node, do prefix node from other modules</span>
        <span class="n">pfx</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span><span class="p">:</span>
            <span class="n">pfx</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodeid</span><span class="p">),</span>
                <span class="s1">&#39;text&#39;</span><span class="p">:</span> <span class="n">pfx</span> <span class="o">+</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">}</span>

        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STMT_ICONS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span>
                                           <span class="s1">&#39;fas fa-lg fa-exclamation-triangle&#39;</span><span class="p">)</span>

        <span class="c1"># As data is an OrderedDict, the key insertion order will be stored.</span>
        <span class="c1"># Keys will typically be displayed in this same order by the UI, so</span>
        <span class="c1"># the insertion order should be chosen with care.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1">#</span>
        <span class="c1"># Initial data - self-explanatory and immediately relevant to users</span>
        <span class="c1">#</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nodetype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;i_this_not_supported&#39;</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;deviation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;not-supported&#39;</span>
            <span class="k">if</span> <span class="s1">&#39;a_attr&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;a_attr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">node</span><span class="p">[</span><span class="s1">&#39;a_attr&#39;</span><span class="p">][</span><span class="s1">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ystree-not-supported&quot;</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;status&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">and</span> <span class="n">status</span><span class="o">.</span><span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;deprecated&#39;</span><span class="p">,</span> <span class="s1">&#39;obsolete&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;status&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span><span class="o">.</span><span class="n">arg</span>

        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;leaf&#39;</span><span class="p">,</span> <span class="s1">&#39;leaf-list&#39;</span><span class="p">]:</span>
            <span class="c1"># reserve space in the order; populated by get_stmt_specific_data</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;datatype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;basetype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;module&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">arg</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;revision&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_latest_revision</span>

        <span class="c1">#</span>
        <span class="c1"># Intermediate data - more complex, of interest to intermediate users</span>
        <span class="c1">#</span>

        <span class="n">xpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stmt_node_id</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">prefix_all</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xpath</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;xpath&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xpath</span>

        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;prefix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="p">,</span> <span class="s1">&#39;namespace&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pyang</span><span class="o">.</span><span class="n">statements</span><span class="o">.</span><span class="n">is_mandatory_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mandatory&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;true&#39;</span>
            <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;fas fa-lg fa-exclamation-circle&quot;</span>

        <span class="n">must</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;must&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">must</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;must&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">must</span><span class="o">.</span><span class="n">arg</span>

        <span class="n">when</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;when&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">when</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;when&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">when</span><span class="o">.</span><span class="n">arg</span>

        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Get any additional data based on the statement keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_stmt_specific_data</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Advanced data for skilled users and/or programmatic APIs</span>
        <span class="c1">#</span>

        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NON_SCHEMA_NODETYPES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parent_data</span> <span class="ow">and</span> <span class="s1">&#39;operations&#39;</span> <span class="ow">in</span> <span class="n">parent_data</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;notification&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">parent_data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]):</span>
                <span class="c1"># Input/output/notification subtrees all have the same</span>
                <span class="c1"># access and operations as their parents, as they&#39;re not</span>
                <span class="c1"># part of the data tree.</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_data</span><span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">]</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent_data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_access</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_allowed_ops</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

        <span class="n">xpath_pfx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stmt_node_id</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">prefix_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xpath_pfx</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;xpath_pfx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xpath_pfx</span>

        <span class="n">schema_node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stmt_node_id</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;schema&#39;</span><span class="p">,</span>
                                               <span class="n">prefix_all</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">schema_node_id</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;schema_node_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">schema_node_id</span>

        <span class="c1"># To reduce confusion but not clutter the tree too much,</span>
        <span class="c1"># we include not-supported nodes in the tree (so the user isn&#39;t</span>
        <span class="c1"># confused by their total absence), but do not descend</span>
        <span class="c1"># to their own child nodes if any.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;i_this_not_supported&#39;</span><span class="p">):</span>
            <span class="c1"># Recurse and add children of this Statement.</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="s1">&#39;typedef&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span>
                                                                <span class="s2">&quot;i_typedefs&quot;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_typedefs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                        <span class="n">child</span><span class="p">,</span> <span class="n">parent_data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span>
                        <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

            <span class="c1"># Unlike &#39;typedef&#39;, &#39;identity&#39; can only exist at the</span>
            <span class="c1"># module/submodule level, so we don&#39;t need to check for</span>
            <span class="c1"># an i_identities attribute here.</span>

            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;grouping&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span> <span class="ow">and</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;i_groupings&#39;</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_groupings</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                        <span class="n">child</span><span class="p">,</span> <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s2">&quot;i_children&quot;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">i_children_ordered</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">:</span>
                        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                            <span class="n">child</span><span class="p">,</span> <span class="n">parent_data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                            <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

            <span class="c1"># Append any children that were marked as not-supported by a</span>
            <span class="c1"># &#39;deviation&#39; statement and so are not included in stmt.i_children.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s2">&quot;i_not_supported&quot;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">unsupported</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_not_supported</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">unsupported</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_nodetypes</span><span class="p">:</span>
                        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_data</span><span class="p">(</span>
                            <span class="n">unsupported</span><span class="p">,</span> <span class="n">parent_data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                            <span class="n">node_callback</span><span class="o">=</span><span class="n">node_callback</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">children</span>

        <span class="c1"># Nodes only have a basetype if they have a derived (non-base) datatype</span>
        <span class="c1"># If no basetype is needed, delete the placeholder added above.</span>
        <span class="k">if</span> <span class="s1">&#39;basetype&#39;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;basetype&#39;</span><span class="p">]:</span>
            <span class="k">del</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;basetype&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node_callback</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node_callback</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="n">stmt</span><span class="p">,</span> <span class="n">parent_data</span><span class="o">=</span><span class="n">parent_data</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span></div>

<div class="viewcode-block" id="ParseYang.i_children_ordered"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.i_children_ordered">[docs]</a>    <span class="k">def</span> <span class="nf">i_children_ordered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Ordered list of child Statements of the given Statement.</span>

<span class="sd">        Helper method to :meth:`get_node_data`.</span>

<span class="sd">        Mostly we respect the order of statements provided by the module</span>
<span class="sd">        (and hence by pyang), but we have at least one exception:</span>

<span class="sd">          The list&#39;s key nodes are encoded as subelements to the list&#39;s</span>
<span class="sd">          identifier element, in the same order as they are defined within the</span>
<span class="sd">          &quot;key&quot; statement.</span>

<span class="sd">          The rest of the list&#39;s child nodes are encoded as subelements to the</span>
<span class="sd">          list element, after the keys. If the list defines RPC input or</span>
<span class="sd">          output parameters, the subelements are encoded in the same order as</span>
<span class="sd">          they are defined within the &quot;list&quot; statement. Otherwise, the</span>
<span class="sd">          subelements are encoded in any order.</span>

<span class="sd">          -- https://tools.ietf.org/html/rfc6020#section-7.8.5</span>

<span class="sd">        Therefore, we need to ensure that the key nodes are always the</span>
<span class="sd">        first children of a list node.</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): Statement to check children of.</span>
<span class="sd">          data (dict): Data previously constructed for the given stmt.</span>
<span class="sd">        Returns:</span>
<span class="sd">          list: Child statements in the order to be processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">child_statements</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_children</span>
        <span class="k">if</span> <span class="s1">&#39;keys&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;keys&#39;</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">sort_function</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">arg</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1000</span>

            <span class="n">child_statements</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">child_statements</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_function</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">child_statements</span></div>

<div class="viewcode-block" id="ParseYang.get_stmt_node_id"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_stmt_node_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_stmt_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;schema&#39;</span><span class="p">,</span> <span class="n">prefix_all</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build the schema or data node identifier (XPath) for a statement.</span>

<span class="sd">        Helper method to :meth:`get_node_data`.</span>

<span class="sd">        .. seealso:: :meth:`pyang.statements.mk_path_str`</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement) Statement to process.</span>
<span class="sd">          mode (str): One of &#39;schema&#39; or &#39;data&#39;.</span>
<span class="sd">          prefix_all (bool): If True, add namespace prefixes to all</span>
<span class="sd">            identifiers, even those in the current module and submodules.</span>
<span class="sd">            If False, only external module identifiers will be prefixed.</span>

<span class="sd">        Returns:</span>
<span class="sd">          str: XPath for schema or data node identifier, or None for nodes</span>
<span class="sd">            not in the schema tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;schema&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="n">path_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Iterate upwards from this statement until reaching the top</span>
        <span class="k">while</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;module&#39;</span><span class="p">,</span> <span class="s1">&#39;submodule&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">NON_SCHEMA_NODETYPES</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;schema&#39;</span> <span class="ow">or</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NON_DATA_NODETYPES</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prefix_all</span> <span class="ow">or</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pfx</span><span class="p">:</span>
                    <span class="n">path_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">path_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">parent</span>

        <span class="n">path_nodes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_nodes</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># Here and below are helper functions to the above - not generally to be</span>
    <span class="c1"># called directly from elsewhere.</span>
    <span class="c1">#</span>

<div class="viewcode-block" id="ParseYang.get_subst_arg"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_subst_arg">[docs]</a>    <span class="k">def</span> <span class="nf">get_subst_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a substatement and return its arg value, or default.</span>

<span class="sd">        .. seealso:: :meth:`set_data_subst_arg`</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): Parent statement</span>
<span class="sd">          keyword (str): Substatement keyword to find</span>
<span class="sd">          default (str): Value to return if substatement is not found</span>

<span class="sd">        Returns:</span>
<span class="sd">          str: The substatement arg string, or default value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="p">:</span>
            <span class="n">subst</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subst</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">subst</span><span class="o">.</span><span class="n">arg</span>
        <span class="k">return</span> <span class="n">default</span></div>

<div class="viewcode-block" id="ParseYang.set_data_subst_arg"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.set_data_subst_arg">[docs]</a>    <span class="k">def</span> <span class="nf">set_data_subst_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span>
                           <span class="n">data_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a substatement and set its arg value into the data.</span>

<span class="sd">        .. seealso:: :meth:`get_subst_arg`</span>

<span class="sd">        Args:</span>
<span class="sd">          data (dict): Dict to store the resulting value into</span>
<span class="sd">          stmt (pyang.statements.Statement): Parent statement</span>
<span class="sd">          keyword (str): Substatement keyword to find</span>
<span class="sd">          data_key (str): Key to store the value under, if different from</span>
<span class="sd">            the ``keyword``.</span>
<span class="sd">          default (str): Value to set in data if substatement is not found.</span>
<span class="sd">            A value of ``None`` means to not set anything (omit data_key).</span>

<span class="sd">        Returns:</span>
<span class="sd">          str: The value being set, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subst_arg</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data_key</span><span class="p">:</span>
                <span class="n">data_key</span> <span class="o">=</span> <span class="n">keyword</span>
            <span class="n">data</span><span class="p">[</span><span class="n">data_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">val</span></div>

<div class="viewcode-block" id="ParseYang.get_stmt_specific_data"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_stmt_specific_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_stmt_specific_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get node data fields specific to certain statement types.</span>

<span class="sd">        Helper to :meth:`get_node_data`.</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): A statement of any type.</span>
<span class="sd">          node (dict): Node to store information into</span>

<span class="sd">        May set any of the following items under the :attr:`node`&#39;s &quot;data&quot;</span>
<span class="sd">        sub-dictionary:</span>

<span class="sd">        base : str</span>
<span class="sd">          for ``identity`` statements</span>
<span class="sd">        basetype : str</span>
<span class="sd">          for ``typedef`` statements</span>
<span class="sd">        datatype : str</span>
<span class="sd">          for ``leaf`` and ``leaf-list`` statements</span>
<span class="sd">        default : str</span>
<span class="sd">          for statements with a default value (``leaf``, ``choice``,</span>
<span class="sd">          ``leaf-list``, ``typedef``)</span>
<span class="sd">        key : str</span>
<span class="sd">          The string &quot;true&quot;, iff this is a ``leaf`` acting as a list key.</span>
<span class="sd">        keys : list</span>
<span class="sd">          For a ``list`` statement with keys, list of the leaf name(s)</span>
<span class="sd">          acting as keys.</span>
<span class="sd">        options : list</span>
<span class="sd">          - for a ``choice`` statement, list of case names, with prefixes as</span>
<span class="sd">            needed for cases defined elsewhere, e.g.</span>
<span class="sd">            ``[&#39;rfc5277&#39;, &#39;yp:update-filter&#39;]``</span>
<span class="sd">          - for a ``leaf`` or ``leaf-list`` statement, see</span>
<span class="sd">            :meth:`get_type_specific_data`</span>
<span class="sd">        presence : str</span>
<span class="sd">          The string &quot;true&quot;, iff this is a &quot;presence&quot; ``container`` statement.</span>
<span class="sd">        units : str</span>
<span class="sd">          Units associated with a ``leaf``, ``leaf-list``, or ``typedef``</span>

<span class="sd">        May also update the node&#39;s :attr:`icon` value.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">          :meth:`get_type_specific_data`</span>
<span class="sd">            Called from this method for ``leaf`` and ``leaf-list`` statements,</span>
<span class="sd">            may populate additional :attr:`data` according to the statement&#39;s</span>
<span class="sd">            :attr:`datatype`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;anydata&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;anyxml&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;case&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;choice&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s2">&quot;i_default_str&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">case</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;case&#39;</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_children</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">case</span><span class="o">.</span><span class="n">i_module</span> <span class="o">==</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">case</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">case</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span>
                                           <span class="n">case</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;container&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;presence&#39;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;true&#39;</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;grouping&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;identity&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;base&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;input&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;leaf&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s2">&quot;i_default_str&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;datatype&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;datatype&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;leafref&#39;</span><span class="p">:</span>
                <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fas fa-lg fa-external-link-square-alt&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_type_specific_data</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
                <span class="n">keystmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">keystmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Key argument is a space-separated list</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="n">keystmt</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;fas fa-lg fa-key&quot;</span>
                        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;true&#39;</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;leaf-list&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s2">&quot;i_default_str&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;datatype&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_type_specific_data</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
            <span class="n">keystmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keystmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Key argument is a space-separated list,</span>
                <span class="c1"># but pyang keeps it as a string. So we split it here:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;keys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">keystmt</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;notification&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;rpc&#39;</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># No special processing at this time</span>

        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s1">&#39;typedef&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;basetype&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s2">&quot;i_default_str&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_default_str</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_data_subst_arg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">,</span> <span class="n">data_key</span><span class="o">=</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_type_specific_data</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Unknown/unhandled stmt type</span>
            <span class="n">node</span><span class="p">[</span><span class="s1">&#39;icon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fas fa-lg fa-exclamation-triangle&#39;</span></div>

<div class="viewcode-block" id="ParseYang.get_type_specific_data"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_type_specific_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_type_specific_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate data for a leaf/leaf-list based on the given type.</span>

<span class="sd">        Helper method to :meth:`get_stmt_specific_data`.</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): A &#39;type&#39; statement.</span>
<span class="sd">          data (dict): Dict to populate with additional type-specific data.</span>

<span class="sd">        May populate any of the following items into the :attr:`data` dict,</span>
<span class="sd">        depending on the given statement type:</span>

<span class="sd">        base : str</span>
<span class="sd">          The base identity of an ``identityref``</span>
<span class="sd">        basetype : str</span>
<span class="sd">          If the type is a derived type, the base type (such as &quot;string&quot;,</span>
<span class="sd">          &quot;enumeration&quot;, &quot;union&quot;) of this type</span>
<span class="sd">        bits : list</span>
<span class="sd">          For type ``bits``, the bit names, e.g., ``[&#39;SYN&#39;, &#39;ACK&#39;, &#39;RST&#39;]``</span>
<span class="sd">        fraction_digits : int</span>
<span class="sd">          For type ``decimal64``, the number of decimal digits permitted,</span>
<span class="sd">          as in the ``fraction-digits`` YANG statement</span>
<span class="sd">        leafref_path : str</span>
<span class="sd">          The path of a ``leafref``, such as &quot;../interface/name&quot;</span>
<span class="sd">        max : str</span>
<span class="sd">          Maximum valid value for any integer type (``[u]int[8|16|32|64]``)</span>
<span class="sd">          or type ``decimal64``</span>
<span class="sd">        min : str</span>
<span class="sd">          Minimum valid value for any integer type (``[u]int[8|16|32|64]``)</span>
<span class="sd">          or type ``decimal64``</span>
<span class="sd">        members : list</span>
<span class="sd">          For type ``union``, a list of sub-dictionaries corresponding to each</span>
<span class="sd">          member type of the union, for example::</span>

<span class="sd">            [{</span>
<span class="sd">               &#39;datatype&#39;: &#39;enumeration&#39;,</span>
<span class="sd">               &#39;options&#39;: [&#39;yes&#39;, &#39;no&#39;],</span>
<span class="sd">             }, {</span>
<span class="sd">               &#39;datatype&#39;: &#39;enumeration&#39;,</span>
<span class="sd">               &#39;options&#39;: [&#39;alpha&#39;, &#39;beta&#39;],</span>
<span class="sd">             }, {</span>
<span class="sd">               &#39;datatype&#39;: &#39;bits&#39;,</span>
<span class="sd">               &#39;bits&#39;: [&#39;SYN&#39;, &#39;ACK&#39;],</span>
<span class="sd">             }]</span>

<span class="sd">        options : list</span>
<span class="sd">          Depending on the given type.</span>

<span class="sd">          - for type ``boolean``, the list ``[&#39;true&#39;, &#39;false&#39;]``</span>
<span class="sd">          - for type ``enumeration``, the enum name strings, for example,</span>
<span class="sd">            ``[&#39;TRUE&#39;, &#39;FALSE&#39;, &#39;FILE_NOT_FOUND&#39;]``</span>
<span class="sd">          - for type ``identityref``, the target names, for example,</span>
<span class="sd">            ``[&#39;ianaift:ethernetCsmacd&#39;, &#39;ianaift:gigabitEthernet&#39;]``</span>

<span class="sd">        ranges : list</span>
<span class="sd">          For an int type or decimal64 with more than one defined range of</span>
<span class="sd">          valid values, a list of ``min, [max]`` pairs, such as</span>
<span class="sd">          ``[(1, 199), (1300, 2699)]`` or ``[(512, None), (1024, None)]``</span>
<span class="sd">        typespec : dict</span>
<span class="sd">          .. warning::</span>
<span class="sd">            The &quot;typespec&quot; key is frozen and should be considered deprecated.</span>
<span class="sd">            We MUST NOT add any new typespec entries as older versions of</span>
<span class="sd">            :mod:`ysnetconf` WILL demonstrate unexpected and undesirable</span>
<span class="sd">            behavior on encountering these!</span>

<span class="sd">          A dict, if necessary, with key &quot;name&quot; and value of the</span>
<span class="sd">          type string, plus at least one of the following:</span>

<span class="sd">          - for type &#39;enumeration&#39;, a key &quot;values&quot;, with a list of enum</span>
<span class="sd">            (name, value) tuples, e.g. ``[(&#39;yes&#39;, 1), (&#39;no&#39;, 0)]``</span>
<span class="sd">            For backwards compatibility only - consumers of the node data</span>
<span class="sd">            generally only need the ``name``, which can be accessed more easily</span>
<span class="sd">            from the ``options`` key above.</span>

<span class="sd">          - for type &#39;identityref&#39;, a key &quot;iref&quot;, with a list of dicts of form</span>
<span class="sd">            ``{namespace:... prefix:... name:...}``.</span>
<span class="sd">            For backwards compatibility only - the ``name`` is accessible more</span>
<span class="sd">            easily via ``options`` above, the ``prefix`` is trivial to extract</span>
<span class="sd">            from the ``name``, and the ``namespace`` can be identified from</span>
<span class="sd">            this tree&#39;s root node&#39;s &#39;namespace_prefixes` data.</span>

<span class="sd">          - for nodes of any int type (``[u]int[8|16|32|64]``), the keys</span>
<span class="sd">            &quot;min&quot; and &quot;max&quot;, describing the minimum and maximum valid values.</span>
<span class="sd">            For backwards compatibility only - these keys are also available</span>
<span class="sd">            directly on the ``data`` dictionary itself now.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;i_type_spec&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This happens if pyang was unable to find the base typedef</span>
            <span class="c1"># for this type.</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_typedefs</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No typedef found for type </span><span class="si">%s</span><span class="s2"> (used at </span><span class="si">%s</span><span class="s2">) --&quot;</span>
                            <span class="s2">&quot; yangset may be incomplete or may contain&quot;</span>
                            <span class="s2">&quot; incompatible module versions&quot;</span><span class="p">,</span>
                            <span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">get_stmt_node_id</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">parent</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">missing_typedefs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Otherwise, let&#39;s handle various built-in types as appropriate:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">BitTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;bits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">bits</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">BooleanTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;true&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">EnumTypeSpec</span><span class="p">):</span>
            <span class="n">spec</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">enums</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">[</span><span class="s1">&#39;values&#39;</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">IdentityrefTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subst_arg</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;base&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">]:</span>
                <span class="c1"># Might be identityref in a typedef so check idbases</span>
                <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">idbases</span><span class="p">:</span>
                    <span class="n">base</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">idbases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">arg</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_identityrefs</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">IntTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
            <span class="n">spec</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span>
            <span class="n">spec</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">PathTypeSpec</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="s1">&#39;i_expanded_path&#39;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;leafref_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">i_expanded_path</span>
            <span class="c1"># Treat the target leaf as the base type</span>
            <span class="n">subtype_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="s1">&#39;i_target_node&#39;</span><span class="p">):</span>
                <span class="n">target_type</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">i_target_node</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_type_specific_data</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">subtype_data</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;typespec&#39;</span> <span class="ow">in</span> <span class="n">subtype_data</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;basetype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtype_data</span><span class="p">[</span><span class="s1">&#39;typespec&#39;</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">subtype_data</span><span class="p">[</span><span class="s1">&#39;typespec&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;leafref_path&#39;</span> <span class="ow">in</span> <span class="n">subtype_data</span><span class="p">:</span>
                    <span class="c1"># Leafref to a leafref - keep the original, don&#39;t overwrite</span>
                    <span class="k">del</span> <span class="n">subtype_data</span><span class="p">[</span><span class="s1">&#39;leafref_path&#39;</span><span class="p">]</span>
            <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subtype_data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">UnionTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;members&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">subtype</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
                <span class="n">subspec</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_type_specific_data</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">subspec</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;typespec&#39;</span> <span class="ow">in</span> <span class="n">subspec</span><span class="p">:</span>
                    <span class="c1"># union has never had typespec, let&#39;s not add it now.</span>
                    <span class="k">del</span> <span class="n">subspec</span><span class="p">[</span><span class="s1">&#39;typespec&#39;</span><span class="p">]</span>
                <span class="n">subspec</span><span class="p">[</span><span class="s1">&#39;datatype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtype</span><span class="o">.</span><span class="n">arg</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;members&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subspec</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;members&#39;</span><span class="p">]:</span>
                <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;members&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">RangeTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">ranges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Complex set of ranges, beyond just &#39;min..max&#39;</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">ranges</span><span class="p">:</span>
                    <span class="n">rmin</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rmin</span><span class="p">)</span>
                    <span class="n">rmax</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rmax</span><span class="p">)</span>
                    <span class="n">ranges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">))</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ranges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ranges</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="s1">&#39;fraction_digits&#39;</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;fraction_digits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">fraction_digits</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Decimal64TypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;fraction_digits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">fraction_digits</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">EmptyTypeSpec</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">PatternTypeSpec</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;patterns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">res</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">StringTypeSpec</span><span class="p">):</span>
            <span class="c1"># NX-OS has its own custom pattern annotation,</span>
            <span class="c1"># which pyang doesn&#39;t recognize but we want to do so.</span>
            <span class="c1"># When pyang parses the YANG model, type constraints</span>
            <span class="c1"># &quot;bubble up&quot; from base types to the derived types; in order to</span>
            <span class="c1"># get the same behavior here (starting from the derived type)</span>
            <span class="c1"># we have to &quot;drill down&quot; until we reach the base type that has</span>
            <span class="c1"># the pattern-posix annotation on it.</span>
            <span class="n">patterns_posix</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">type_stmt</span> <span class="o">=</span> <span class="n">stmt</span>
            <span class="k">while</span> <span class="n">type_stmt</span><span class="p">:</span>
                <span class="n">patterns_posix</span> <span class="o">=</span> <span class="n">type_stmt</span><span class="o">.</span><span class="n">search</span><span class="p">((</span><span class="s1">&#39;Cisco-NX-OS-mtx&#39;</span><span class="p">,</span>
                                                   <span class="s1">&#39;pattern-posix&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">patterns_posix</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">type_stmt</span><span class="o">.</span><span class="n">i_typedef</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">type_stmt</span> <span class="o">=</span> <span class="n">type_stmt</span><span class="o">.</span><span class="n">i_typedef</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">patterns_posix</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;patterns&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pstmt</span><span class="o">.</span><span class="n">arg</span> <span class="k">for</span> <span class="n">pstmt</span> <span class="ow">in</span> <span class="n">patterns_posix</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">LengthTypeSpec</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Complex LengthTypeSpec encountered; &quot;</span>
                            <span class="s2">&quot;not yet fully handled by YANG Suite&quot;</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;minLength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;maxLength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">,</span> <span class="n">pyang</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">BinaryTypeSpec</span><span class="p">):</span>
            <span class="c1"># base64 encoding/decoding</span>
            <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Unfamiliar typespec (</span><span class="si">%s</span><span class="s2">) encountered, unhandled&quot;</span><span class="p">,</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">spec</span><span class="p">:</span>
            <span class="n">spec</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">name</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;typespec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>

        <span class="k">if</span> <span class="s1">&#39;datatype&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;datatype&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;basetype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">name</span></div>

        <span class="c1"># TODO: handle union with a single member (roll up)</span>
        <span class="c1"># see Cisco-IOS-XE-sla leaf url type union { type string }</span>

    <span class="k">def</span> <span class="nf">_add_nspdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to add prefix/namespace if not already there.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pfx</span><span class="p">,</span> <span class="n">mod_rev</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefixes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspdata</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">mod</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mod_rev</span>
            <span class="n">module</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">get_module</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">module</span><span class="p">:</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="n">module</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;namespace&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nspdata</span><span class="p">[</span><span class="n">pfx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">arg</span>

    <span class="k">def</span> <span class="nf">_get_identityrefs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method to :meth:`get_type_specific_data`.&quot;&quot;&quot;</span>
        <span class="n">base_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pfx</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">search_one</span><span class="p">(</span><span class="s1">&#39;base&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span>
            <span class="c1"># This might be a typedef</span>
            <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">idbases</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_type_spec</span><span class="o">.</span><span class="n">idbases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">identities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">base</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span> <span class="p">{}</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">ids</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_add_nspdata</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                    <span class="n">base_list</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base_list</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># all identityref should have a base</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> identityref without a base&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">arg</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">base_list</span>

        <span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">arg</span><span class="p">:</span>
            <span class="n">pfx</span><span class="p">,</span> <span class="n">base_idt</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_idt</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">arg</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">pfx</span> <span class="ow">or</span> <span class="n">pfx</span> <span class="o">==</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefix</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">stmt</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">identities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mod</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">i_module</span><span class="o">.</span><span class="n">i_prefixes</span><span class="p">[</span><span class="n">pfx</span><span class="p">]</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">identities</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="p">{})</span>

        <span class="k">if</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">base_list</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base_idt</span><span class="p">,</span> <span class="p">[])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_nspdata</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base_list</span><span class="p">)</span>

<div class="viewcode-block" id="ParseYang.get_access"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_access">[docs]</a>    <span class="k">def</span> <span class="nf">get_access</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a string describing the access type of the given Statement.</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): Statement to inspect.</span>
<span class="sd">        Returns:</span>
<span class="sd">          str: One of &#39;read-only&#39;, &#39;read-write&#39;, or &#39;write&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rpc&#39;</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;action&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;write&#39;</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;notification&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s1">&#39;read-only&#39;</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;i_config&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">stmt</span><span class="o">.</span><span class="n">i_config</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;read-write&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;read-only&#39;</span></div>

    <span class="n">_OPS_NONE</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_OPS_ACTION</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;action&#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">_OPS_RPC</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;rpc&#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">_OPS_NOTIFICATION</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;notification&#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">_OPS_INPUT</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">_OPS_OUTPUT</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">_OPS_READONLY</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;get&#39;</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">_OPS_DEFAULT</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;edit-config&#39;</span><span class="p">,</span> <span class="s1">&#39;get-config&#39;</span><span class="p">,</span> <span class="s1">&#39;get&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ParseYang.get_allowed_ops"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.ParseYang.get_allowed_ops">[docs]</a>    <span class="k">def</span> <span class="nf">get_allowed_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the set of data operations applicable to this node and module.</span>

<span class="sd">        Args:</span>
<span class="sd">          stmt (pyang.statements.Statement): Node being inspected</span>
<span class="sd">          data (dict): Data dictionary to set key &#39;operations&#39; on</span>
<span class="sd">          tree (dict): Root of node data tree containing the ``data``.</span>
<span class="sd">            If given, ``tree[&#39;data&#39;][&#39;operations&#39;]`` may be updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;choice&#39;</span><span class="p">,</span> <span class="s1">&#39;case&#39;</span><span class="p">]:</span>
            <span class="c1"># These statements are not part of the data tree, only schema tree.</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_NONE</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;action&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_ACTION</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rpc&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_RPC</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;notification&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_NOTIFICATION</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_INPUT</span>
        <span class="k">elif</span> <span class="n">stmt</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_OUTPUT</span>
        <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;access&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;read-only&#39;</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_READONLY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OPS_DEFAULT</span>

        <span class="k">if</span> <span class="n">tree</span><span class="p">:</span>
            <span class="c1"># Also update the module-level set of operations if needed.</span>
            <span class="c1"># The input and output operations are sub-operations of the</span>
            <span class="c1"># rpc operation and so are not applicable to the module as a whole.</span>
            <span class="n">new_ops</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;operations&#39;</span><span class="p">])</span>
                       <span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">])</span>
                       <span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">}))</span>
            <span class="k">if</span> <span class="n">new_ops</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
                <span class="n">tree</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;operations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">new_ops</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return YANG model name parsed by class.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="TreeWalker"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.TreeWalker">[docs]</a><span class="k">class</span> <span class="nc">TreeWalker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Utility class used by ParseYang to walk the jstree.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save jstree.</span>

<span class="sd">        Args:</span>
<span class="sd">          tree (dict): contains dict created by ParseYang</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span>

    <span class="k">def</span> <span class="nf">_walk_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Descend through the provided subtree until the given node is found.</span>

<span class="sd">        Args:</span>
<span class="sd">          child (dict): jstree or subtree thereof</span>
<span class="sd">          xpath (str): XPath string to match on</span>
<span class="sd">          node_id (str): Node ID value to match on</span>
<span class="sd">          parents (list): List to populate with node IDs of nodes encountered</span>
<span class="sd">            en route to successfully locating the child.</span>
<span class="sd">        Returns:</span>
<span class="sd">          dict: node matching the requested xpath/node_id, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xpath</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;xpath&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">node_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">))</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parents&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">no_prefix</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;no_prefix&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xpath</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">child</span> <span class="ow">and</span> <span class="s1">&#39;xpath&#39;</span> <span class="ow">in</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">no_prefix</span><span class="p">:</span>
                    <span class="n">ch_path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;xpath&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">token</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">token</span><span class="p">:</span>
                            <span class="n">ch_path</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">token</span>
                    <span class="k">if</span> <span class="n">ch_path</span> <span class="o">==</span> <span class="n">xpath</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">child</span>
                <span class="k">elif</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;xpath&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">xpath</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">child</span>
        <span class="k">elif</span> <span class="s1">&#39;id&#39;</span> <span class="ow">in</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">node_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">child</span>

        <span class="k">if</span> <span class="s1">&#39;children&#39;</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk_child</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
                    <span class="k">return</span> <span class="n">match</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_walk_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="TreeWalker.get_node_by_xpath"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.TreeWalker.get_node_by_xpath">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_by_xpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Walk the jstree and return node that matches the xpath.</span>

<span class="sd">        Args:</span>
<span class="sd">          xpath (str): Xpath of the node in the tree to match.</span>
<span class="sd">          parents (list): optional list object passed in to be populated</span>
<span class="sd">                          with the node IDs of the parents relating to the</span>
<span class="sd">                          node that matches the Xpath.</span>

<span class="sd">        Returns:</span>
<span class="sd">          dict: contains all the data specific to the node constructed</span>
<span class="sd">          by ParseYang.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk_tree</span><span class="p">(</span><span class="n">xpath</span><span class="o">=</span><span class="n">xpath</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;parents&#39;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">if</span> <span class="n">parents</span><span class="p">:</span>
            <span class="c1"># first node ID in the list is the matched node so remove it</span>
            <span class="n">parents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span></div>

<div class="viewcode-block" id="TreeWalker.get_node_by_id"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.TreeWalker.get_node_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_by_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Walk the jstree and return node that matches the xpath.</span>

<span class="sd">        Args:</span>
<span class="sd">          node_id (str, int): node ID of the node in the tree to match.</span>
<span class="sd">          parents (list): optional list object passed in to be populated</span>
<span class="sd">                          with the node IDs of the parents relating to the</span>
<span class="sd">                          node that matches the Xpath.</span>

<span class="sd">        Returns:</span>
<span class="sd">          dict: contains all the data specific to the node constructed</span>
<span class="sd">          by ParseYang.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk_tree</span><span class="p">(</span><span class="n">node_id</span><span class="o">=</span><span class="n">node_id</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parents</span><span class="p">:</span>
            <span class="c1"># first node ID in the list is the matched node so remove it</span>
            <span class="n">parents</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">node</span></div>

<div class="viewcode-block" id="TreeWalker.get_dataset"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.TreeWalker.get_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="p">[],</span> <span class="o">*</span><span class="n">addons</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return xpath plus optional add-ons.</span>

<span class="sd">        Args:</span>
<span class="sd">          child (dict): Root of jstree compiled by ParseYang (can be self.tree)</span>
<span class="sd">          items (list) or (set): Container to place results in.</span>
<span class="sd">          addons (tuple): Optional desired data</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; from ysyangtree import YSContext, YSYangModels</span>
<span class="sd">        &gt;&gt;&gt; ctx = YSContext.get_instance(&#39;admin&#39;, &#39;admin+miott-csr-no-mib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; models = YSYangModels(ctx, [&#39;Cisco-IOS-XE-native&#39;])</span>
<span class="sd">        &gt;&gt;&gt; parser = models.yangs[&#39;Cisco-IOS-XE-native&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset = parser.tw.get_dataset(</span>
<span class="sd">        ...     parser.tw.tree, [], &#39;nodetype&#39;, &#39;datatype&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset[0]</span>
<span class="sd">        [&#39;/native&#39;, &#39;container&#39;, &#39;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset[1]</span>
<span class="sd">        [&#39;/native/default&#39;, &#39;container&#39;, &#39;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset[2]</span>
<span class="sd">        [&#39;/native/default/crypto&#39;, &#39;container&#39;, &#39;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset[3]</span>
<span class="sd">        [&#39;/native/default/crypto/ikev2&#39;, &#39;container&#39;, &#39;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset[4]</span>
<span class="sd">        [&#39;/native/default/crypto/ikev2/proposal&#39;, &#39;leaf&#39;, &#39;empty&#39;]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; dataset2 = parser.tw.get_dataset(</span>
<span class="sd">        ...     parser.tw.tree, set(), &#39;nodetype&#39;, &#39;datatype&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; dataset2.pop()</span>
<span class="sd">        (&#39;/native/spanning-tree/ios-stp:extend&#39;, &#39;container&#39;, &#39;&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        Returns:</span>
<span class="sd">          (list): Multidimensional list or strings containing interesting data.</span>
<span class="sd">          (set): Set of tuples containing interesting data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">child</span> <span class="ow">and</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">child</span> <span class="ow">and</span> <span class="s1">&#39;xpath&#39;</span> <span class="ow">in</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
            <span class="n">nodedata</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;xpath&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">addons</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
                    <span class="n">nodedata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">item</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodedata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">):</span>
                <span class="c1"># set cannot add lists so combine into a single string</span>
                <span class="n">items</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nodedata</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodedata</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;children&#39;</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">child</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="o">*</span><span class="n">addons</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">items</span></div>

<div class="viewcode-block" id="TreeWalker.get_dataset_using_key"><a class="viewcode-back" href="../../developer/ysyangtree.ymodels.html#ysyangtree.ymodels.TreeWalker.get_dataset_using_key">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataset_using_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">xpath</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">addons</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return xpath plus optional add-ons and submodule tag.</span>

<span class="sd">        Args:</span>
<span class="sd">          node (dict): Root of jstree compiled by ParseYang (can be self.tree)</span>
<span class="sd">          key (string): Key in the data node</span>
<span class="sd">          items (list) or (set): Container to place results in.</span>
<span class="sd">          xpath (xpath) : xpath for the data node</span>
<span class="sd">          addons (tuple): Optional desired data</span>

<span class="sd">        Example usage:</span>

<span class="sd">        &gt;&gt;&gt; from ysyangtree import YSContext, YSYangModels</span>
<span class="sd">        &gt;&gt;&gt; ctx = YSContext.get_instance(&#39;admin&#39;, &#39;admin+miott-csr-no-mib&#39;)</span>
<span class="sd">        &gt;&gt;&gt; models = YSYangModels(ctx, [&#39;Cisco-IOS-XE-logging&#39;])</span>
<span class="sd">        &gt;&gt;&gt; parser = models.yangs[&#39;Cisco-IOS-XE-&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset = parser.tw.get_dataset_using_key(</span>
<span class="sd">        ...     parser.tw.tree, &#39;name&#39;, [], &#39;&#39;, &#39;module&#39;, &#39;nodetype&#39;</span>
<span class="sd">        d)</span>
<span class="sd">        &gt;&gt;&gt; dataset[0]</span>
<span class="sd">        [&#39;/logging/discriminator/name&#39;,</span>
<span class="sd">          &#39;&#39;,</span>
<span class="sd">          &#39;Cisco-IOS-XE-logging&#39;,</span>
<span class="sd">          &#39;leaf&#39;,</span>
<span class="sd">          &#39;submodule&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset[1]</span>
<span class="sd">        [&#39;/logging/discriminator/severity/drops&#39;,</span>
<span class="sd">         &#39;&#39;,</span>
<span class="sd">         &#39;Cisco-IOS-XE-logging&#39;,</span>
<span class="sd">         &#39;leaf&#39;,</span>
<span class="sd">         &#39;submodule&#39;]</span>
<span class="sd">        &gt;&gt;&gt; dataset[2]</span>
<span class="sd">        [&#39;/logging/discriminator/severity/includes&#39;,</span>
<span class="sd">         &#39;&#39;,</span>
<span class="sd">         &#39;Cisco-IOS-XE-logging&#39;,</span>
<span class="sd">         &#39;leaf&#39;,</span>
<span class="sd">         &#39;submodule&#39;]</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        Returns:</span>
<span class="sd">          (list): Multidimensional list or strings containing interesting data.</span>
<span class="sd">          (set): Set of tuples containing interesting data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="s1">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">node</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;nodetype&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nodetype&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">NON_DATA_NODETYPES</span><span class="p">:</span>
                    <span class="n">xpath</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="n">nodedata</span> <span class="o">=</span> <span class="p">[</span><span class="n">xpath</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">addons</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">nodedata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nodedata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">nodedata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;submodule&#39;</span><span class="p">)</span>

            <span class="c1"># Filter out xpaths from non-data nodetypes</span>
            <span class="n">itemappend</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="s1">&#39;nodetype&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nodetype&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">NON_DATA_NODETYPES</span><span class="p">:</span>
                    <span class="n">itemappend</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nodetype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;container&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s1">&#39;presence&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;presence&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;true&#39;</span><span class="p">:</span>
                            <span class="n">itemappend</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s1">&#39;presence&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                                <span class="n">itemappend</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">itemappend</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">):</span>
                    <span class="c1"># set cannot add lists so combine into a single string</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">nodedata</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodedata</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;children&#39;</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;children&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_dataset_using_key</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">items</span><span class="p">,</span> <span class="n">xpath</span><span class="p">,</span> <span class="o">*</span><span class="n">addons</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">items</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2018, YANG Suite development team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.19.1.post0.dev3',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>